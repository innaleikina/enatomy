import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _pt from "prop-types";
import React from 'react';
import Parser from './Parser';
import Markup from './Markup';

var Interweave = function (_React$PureComponent) {
  _inherits(Interweave, _React$PureComponent);

  function Interweave() {
    _classCallCheck(this, Interweave);

    return _possibleConstructorReturn(this, _getPrototypeOf(Interweave).apply(this, arguments));
  }

  _createClass(Interweave, [{
    key: "parseMarkup",
    value: function parseMarkup() {
      var _this = this;

      var _ref = this.props,
          tagName = _ref.tagName,
          content = _ref.content,
          emptyContent = _ref.emptyContent,
          onBeforeParse = _ref.onBeforeParse,
          onAfterParse = _ref.onAfterParse,
          matchers = _ref.matchers,
          disableMatchers = _ref.disableMatchers,
          filters = _ref.filters,
          disableFilters = _ref.disableFilters,
          props = _objectWithoutProperties(_ref, ["tagName", "content", "emptyContent", "onBeforeParse", "onAfterParse", "matchers", "disableMatchers", "filters", "disableFilters"]);

      var allMatchers = disableMatchers ? [] : matchers;
      var allFilters = disableFilters ? [] : filters;
      var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];
      var afterCallbacks = onAfterParse ? [onAfterParse] : [];
      allMatchers.forEach(function (matcher) {
        if (matcher.onBeforeParse) {
          beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));
        }

        if (matcher.onAfterParse) {
          afterCallbacks.push(matcher.onAfterParse.bind(matcher));
        }
      });
      var markup = beforeCallbacks.reduce(function (string, callback) {
        var nextString = callback(string, _this.props);

        if ("production" !== process.env.NODE_ENV) {
          if (typeof nextString !== 'string') {
            throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');
          }
        }

        return nextString;
      }, content || '');
      var parser = new Parser(markup, props, allMatchers, allFilters);
      var nodes = afterCallbacks.reduce(function (parserNodes, callback) {
        var nextNodes = callback(parserNodes, _this.props);

        if ("production" !== process.env.NODE_ENV) {
          if (!Array.isArray(nextNodes)) {
            throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');
          }
        }

        return nextNodes;
      }, parser.parse());

      if (nodes.length === 0) {
        return emptyContent;
      }

      return nodes;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          disableLineBreaks = _this$props.disableLineBreaks,
          disableWhitelist = _this$props.disableWhitelist,
          emptyContent = _this$props.emptyContent,
          noHtml = _this$props.noHtml,
          noHtmlExceptMatchers = _this$props.noHtmlExceptMatchers,
          tagName = _this$props.tagName;
      return React.createElement(Markup, {
        disableLineBreaks: disableLineBreaks,
        disableWhitelist: disableWhitelist,
        emptyContent: emptyContent,
        noHtml: noHtml,
        noHtmlExceptMatchers: noHtmlExceptMatchers,
        tagName: tagName,
        parsedContent: this.parseMarkup()
      });
    }
  }]);

  return Interweave;
}(React.PureComponent);

_defineProperty(Interweave, "propTypes", {
  disableFilters: _pt.bool,
  disableMatchers: _pt.bool,
  filters: _pt.arrayOf(_pt.any),
  matchers: _pt.arrayOf(_pt.any),
  onAfterParse: _pt.oneOfType([_pt.any, _pt.oneOf([null])]),
  onBeforeParse: _pt.oneOfType([_pt.any, _pt.oneOf([null])]),
  transform: _pt.oneOfType([_pt.any, _pt.oneOf([null])])
});

_defineProperty(Interweave, "defaultProps", {
  content: '',
  disableFilters: false,
  disableLineBreaks: false,
  disableMatchers: false,
  disableWhitelist: false,
  emptyContent: null,
  filters: [],
  matchers: [],
  noHtml: false,
  noHtmlExceptMatchers: false,
  onAfterParse: null,
  onBeforeParse: null,
  tagName: 'span',
  transform: null
});

export { Interweave as default };